---
## 準備工作：測試字串與函數定義

在開始編寫函數之前，首先建立一個**測試字串**非常有用。我們將這個字串命名為 `text`。測試字串的目的是在開發過程中能夠即時測試函數的進度。

這個函數的目標是追蹤所有**唯一詞彙**並計算它們的**頻率**，因此我們將其命名為 `count_words`。作為一個函數，它需要使用 `def` 語句，並且唯一的輸入參數就是 `text`。

我們決定使用**字典**來解決這個任務。首先，我們將創建一個名為 `word_counts` 的空字典。

---
## 將文字分解為單詞並遍歷

下一步是將文字分解為單詞。我們將使用 `split` 方法，並以**空格**作為分隔符。這會產生一個**列表**，我們可以對其進行遍歷，因此我們需要一個 `for` 迴圈。因為列表中的項目是單詞，我們將使用 `word` 作為迴圈變數，即 `for word in text.split()`。

---
## 處理單詞計數邏輯

在遍歷文字時，有兩種情況可能發生：

1.  **已知單詞**：如果遇到以前見過的單詞，我們需要將該單詞在字典中對應的計數器加一。
2.  **未知單詞**：如果遇到以前從未見過的單詞，我們需要在字典中建立一個新的條目，並將其計數器初始化為 1。

我們將這兩種情況分為兩個子任務來處理。

---
### 處理已知單詞

我們需要檢查這個單詞是否之前出現在字典中。這需要一個 `if` 語句：`if word in word_counts:`。

如果條件為真，則表示我們已經見過這個單詞。我們需要存取 `word_counts` 字典，並將該單詞的計數器加 1。這裡可以使用簡寫操作：`word_counts[word] += 1`。

---
### 處理未知單詞

另一種情況是遇到以前未見過的單詞。這時可以使用 `else` 語句。

在這種情況下，我們仍然需要存取 `word_counts` 字典，但是需要將計數器設置為 1，因為這是我們第一次看到這個單詞：`word_counts[word] = 1`。

---
## 函數的返回值和文檔字串

至此，我們已經準備好將字典返回給呼叫函數的地方。我們需要在程式碼中添加一個 `return` 語句：`return word_counts`。

在繼續之前，務必在函數中添加**文檔字串 (docstring)**，以便說明函數的功能。

---
## 執行函數並測試

定義好函數後，我們就可以執行它了。確保我們的測試文字也已定義，然後就可以嘗試執行函數並查看結果。

---
### 初始結果與問題點

正如預期，Python 返回了一個字典，其中**鍵**是唯一的單詞，**值**是每個單詞在文字中出現的次數。

檢視字典，目前程式的一個明顯缺點是它將**標點符號**（如句號或句點）也作為單詞的一部分。這會導致單詞計數的膨脹，因為例如，出現在句子中間的單詞會與出現在句子末尾並緊隨句點的相同單詞分開計數。

另一個問題是，如果單詞出現在句子的開頭，其第一個字母會**大寫**，再次導致某些單詞重複計數。

---
## 解決大小寫和標點符號問題

為了解決這些問題，我們將首先將文字轉換為**小寫**。這意味著無論單詞是否大寫，都將計為同一個單詞。

處理標點符號會稍微複雜一些。我們的策略是：

1.  首先指定所有要跳過的標點符號。
2.  然後遍歷這些標點符號，將文字中每個出現的標點符號替換為空字串。

---
### 將文字轉換為小寫

我們可以使用 `lower` 方法來實現這一點，然後重新捕獲新的文字：`text = text.lower()`。

---
### 定義要跳過的標點符號

其次，我們需要定義在遍歷文字時將要跳過的字元。我們將為此構造一個**列表**，其中可以包含一些最常見的標點符號，例如句點、逗號、分號、冒號、單引號和雙引號。

值得注意的是，在定義雙引號時，我們必須使用**單引號**將其括起來，因為雙引號本身也用於開始和結束字串。這就是為什麼我們將使用單引號來表示我們實際要表示的字元——雙引號。

---
### 替換標點符號

接下來，我們將遍歷所有要跳過的字元，並將它們替換為**空字串**。這需要一個 `for` 迴圈。

我們將獲取 `text`，並將每個 `ch` (要跳過的字元) 替換為一個空字串：`text = text.replace(ch, '')`。我們還需要確保捕獲 `replace` 方法返回的修改後的字串。

---
### 更新文檔字串並重新測試

最後，為了完成對函數的修改，我們需要更新**文檔字串**以反映我們剛剛所做的更改，例如添加「跳過標點符號」。

然後，我們運行函數定義，並使用之前定義的測試字串再次運行函數。這次，在查看輸出時，你會注意到所有鍵都是**小寫**的，並且我們定義的標點符號也已經被刪除。

---
## 使用 `collections.Counter` 提升效率

能夠編寫自己的計數程序固然有用，但是計算對象頻率是一個非常常見的操作，Python 提供了一個名為 `Counter` 的工具來支持快速計數。

我們首先需要從 `collections` 模組中匯入它，該模組提供了許多額外的高性能資料類型。`Counter` 返回的對象行為非常像字典，儘管嚴格來說它是 Python 字典對象的一個子類。

---
### 使用 `Counter` 修改函數

讓我們修改函數以使用 `Counter` 對象。在這裡，我們希望保留原始函數和使用 `Counter` 對象的函數。

第一步是**匯入** `Counter`：`from collections import Counter`。

為了開始編寫函數，我們將複製原始函數的程式碼。因為這個函數使用 `collections` 中的 `Counter` 對象，我們將其命名為 `count_words_fast`。

計數部分發生在程式碼的最後幾行。我們不會更改第一部分（將文字轉換為小寫）和跳過標點符號的部分。唯一會改變的是對文字字串中每個單詞的遍歷。

程式碼的最後幾行可以簡單地用一個表達式替換。我們將在這一行定義 `word_counts`，這是我們第一次使用它。`Counter` 對象的輸入將是我們用於計數的文字。我們將獲取 `text`，將其分割以獲取單詞，然後就完成了：`word_counts = Counter(text.split())`。

---
### 執行並比較結果

在運行函數之前，讓我們先執行匯入語句。

現在我們可以運行函數的定義，然後在測試資料集上進行測試。同樣，正如預期，函數返回一個 `Counter` 對象，它基本上與字典對象相同。

讓我們看看這兩個不同函數返回的對象是否真的相同。我們將首先使用我們的文字呼叫 `count_words` 函數，然後詢問 Python 它是否等於 `count_words_fast` 在相同輸入上返回的對象。

在本例中，答案是 `True`，因此我們知道這兩個不同實作的相同函數返回了相同的對象。

---
## 閱讀文件：`read_book` 函數

我們現在熟悉讀取文件。這裡我們將包含一個額外的參數。**字元編碼 (Character encoding)** 是指電腦如何編碼某些字元的過程。在這裡，我們將使用 **UTF-8 編碼**，這是網路中最主要的字元編碼。

我們還將替換 `\n` (換行符) 和 `\r` (回車符) 字元。由於這個函數讀取一本書，我們將簡單地將其命名為 `read_book`。

輸入參數需要書本標題的路徑，因此我們將這個參數命名為 `title_path`。由於我們正在定義一個函數，開頭需要通常的 `def` 語句。

---
### `read_book` 函數的實作

我們將從編寫**文檔字串**開始。這個函數將讀取一本書並將其作為字串返回。

我們將使用之前案例研究中看到的 `with` 語句。所以，`with open(title_path, 'r', encoding='utf8') as current_file:`，我們以讀取模式打開文件，並指定編碼為 `utf8`。我們將此文件打開為 `current_file`。

我們將通過讀取 `current_file` 來獲取文字。

---
### 處理特殊字元

接下來的步驟是將 `\n` 和 `\r` 字元替換為空字串。因此，我們獲取 `text`，首先將 `\n` 替換為空字串。這會返回一個字串，我們可以緊接在第一個 `replace` 方法之後鏈接第二個 `replace` 方法。在第二個 `replace` 中，我們將 `\r` 替換為空字串。最後，我們需要確保捕獲剛剛創建的對象。

至此，只剩下將 `text` 對象返回給呼叫者。

---
### 測試 `read_book` 函數

我們可以試試我們的程式碼，讀取莎士比亞的《羅密歐與茱麗葉》。

首先運行函數定義，這樣我們的函數就被定義了。現在我們已經準備好讀取一本書。在這裡，我們將手動輸入路徑。

查看長度，我們將看到 Python 已經讀取了大約 17 萬個字元，這是莎士比亞《羅密歐與茱麗葉》的全部內容。

《羅密歐與茱麗葉》中有一句名言。讓我們看看是否能找到它。為此，我們將使用 `find` 方法。這句話以「What's in a name?」開頭。`find` 方法如果找到子字串，將返回其索引。讓我們看看會發生什麼。

在本例中，`find` 方法返回了一個索引，因此我們知道子字串是文字的一部分。讓我們從這個位置提取一個範例文字。所以我們將說 `sample_text = text[index:index + 1000]`，即從索引開始，包含 1,000 個字元的一個切片。

---
### 驗證擷取結果

讓我們看看範例文字。在本例中，我們將看到範例文字確實以那句名言「What's in a name?」開頭。因此，我們找到了適當的行。
