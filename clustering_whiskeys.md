# 威士忌風味聚類分析筆記

## 核心方法：光譜共群 (Spectral Co-Clustering)

接下來，我們將根據威士忌的風味特徵對其進行分群。我們將使用 `scikit-learn` 機器學習套件中的一種聚類方法，稱為 **光譜共群 (spectral co-clustering)**。

### 概念源起：詞語與文件

要理解光譜共群，可以想像一個最初應用此方法的場景：分析 **詞語 (words)** 和 **文件 (documents)** 之間的關係。

我們可以將這個問題視覺化為一個圖：

- **左側**：代表不同的詞語 (以圓圈表示)。
- **右側**：代表不同的文件 (以方塊表示)。
- **連線**：表示某個詞語出現在某個文件中。

**示意圖：**

```
  詞語 (Words)      文件 (Documents)
      o --------------- ◻
      o --             /
      o --- ◻ --------/
      o ----/
      o --------------- ◻
      o --/
```

實際上，一個文件會包含許多詞語，上圖僅為簡化示意。

**目標：** 我們的目標是找出由「經常一起出現的詞語集合」和「包含這些詞語的文件集合」所組成的 **群集 (clusters)**。

舉例來說：
- **極端例子**：不同語言撰寫的書籍自然會形成不同的群集。
- **常見例子**：探討特定科學領域（如生物學、物理學）的文件也會和相關的專業詞彙形成群集。

**「共群」(Co-Clustering)** 的概念在於，我們 **同時** 找出詞語的群集和文件的群集。

在示意圖中，可能的群集如下：

- **群集 1**：包含左上方的一組詞語和它們所對應的文件。
- **群集 2**：包含左下方的一組詞語和它們所對應的文件。

每個群集都同時包含了 **詞語** 和 **文件**。

### 數學原理：鄰接矩陣與特徵值

直接解決這個圖形分群問題相當困難，但我們可以找到一個近似解。

1.  **鄰接矩陣 (Adjacency Matrix)**：
    我們將上述的圖轉換為一個矩陣。
    - **行 (Rows)**：對應詞語。
    - **列 (Columns)**：對應文件。
    - **矩陣元素 (Element)**：代表某個詞語在某個文件中出現的次數。

2.  **光譜方法 (Spectral Method)**：
    接著，我們對這個矩陣進行特定的數學運算，並透過計算該矩陣的 **特徵值 (eigenvalues)** 與 **特徵向量 (eigenvectors)** 來找到問題的近似解。

    - **「光譜」(Spectral)** 這個詞的意義，正是指在解決問題時使用了矩陣的特徵值與特徵向量。

> 如果想深入了解特徵值與特徵向量，可以參考任何關於矩陣或線性代數的課程或教科書。

### 應用於威士忌風味分析

我們可以將光譜共群技術視為一種 **同時對矩陣的「行」與「列」進行聚類** 的方法。

在我們的案例中：
- **矩陣**：威士忌風味的 **相關係數矩陣 (correlation matrix)**。
- **行/列**：代表不同的威士忌。

此方法會重新排列相關係數矩陣的行與列，使得代表「一組威士忌」的區塊 (blocks) 能夠更清晰地顯現出來。

由於我們的資料集中的威士忌來自 **六個不同的產區**，我們將要求聚類演算法找出 **六個群集**。

---

## Python 實作步驟

### 1. 匯入並建立模型

首先，從 `scikit-learn` 匯入 `SpectralCoclustering` 方法。

```python
from sklearn.cluster import SpectralCoclustering

# 建立模型物件
model = SpectralCoclustering(
    n_clusters=6,      # 指定要找出的群集數量為 6
    random_state=0     # 設定隨機種子以確保結果可重現
)
```

### 2. 擬合模型

使用威士忌的相關係數矩陣 (`correlation_matrix`) 來訓練 (fit) 模型。

```python
model.fit(correlation_matrix)
```

### 3. 分析聚類結果

#### 查看群集分配

模型的 `rows_` 屬性儲存了分群結果。它是一個陣列，維度為 `(群集數量 x 資料筆數)`。

- 陣列中的值為 `True` 或 `False`。
- 每一 **行 (row)** 代表一個群集 (編號 0 到 5)。
- 每一 **列 (column)** 代表原始相關係數矩陣中的一筆資料 (一支威士忌，編號 0 到 85)。

#### 計算每個群集包含的威士忌數量

我們可以對這個結果陣列的 **列 (columns)** 進行加總，來計算每個群集分配到了多少支威士忌。

```python
import numpy as np

# axis=1 表示對「列」進行加總
whiskey_counts_per_cluster = np.sum(model.rows_, axis=1)

print(whiskey_counts_per_cluster)
# 輸出可能為：[10 15 19 20 12 9]
# 這表示：
# - 群集 0 有 10 支威士忌
# - 群集 1 有 15 支威士忌
# - 群集 2 有 19 支威士忌
# ... 以此類推
```

#### 驗證每筆資料的歸屬

反之，如果我們對 **行 (rows)** 進行加總，可以驗證每支威士忌被分配到了幾個群集。由於每支威士忌只會屬於六個群集中的一個，所以結果應該全部為 `1`。

```python
# axis=0 表示對「行」進行加總
clusters_per_whiskey = np.sum(model.rows_, axis=0)

print(clusters_per_whiskey)
# 輸出應為：[1. 1. 1. ... 1. 1. 1.] (共 86 個 1)
```

#### 查看具體的標籤

模型的 `row_labels_` 屬性直接告訴我們每一筆資料（每一支威士忌）被分配到哪個群集。

```python
print(model.row_labels_)
# 輸出可能為：[5 2 0 3 5 ... ]
# 這表示：
# - 第 0 號威士忌，屬於群集 5
# - 第 1 號威士忌，屬於群集 2
# ... 以此類推
```

陣列中所有的數字都會介於 0 到 5 之間，因為我們一開始就指定了要找出 6 個群集。
